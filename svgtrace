from __future__ import division
import time, sys
from IPython.Shell import IPShellEmbed
from elementtree.ElementTree import ElementTree
import Numeric as num
import pygame

def walk(node):
    for c in node.getchildren():
        if c.tag == '{http://www.w3.org/2000/svg}path':
            tracePath(c)
        walk(c)

class Motors:
    pos = (0,0)
    scl = 1.8
    def __init__(self):
        self.pos = num.array([0, 0])
        self._blade = "up"
        self.surf = pygame.display.set_mode(num.array([360, 360]) * self.scl)
        self.lastUpdateTime = 0

    def blade(self, which="up"):
        if self._blade == which:
            return
        self._blade = which
        
    def moveTo(self, p2):
        """walk to p2 via a 45-degree line and an ortho line"""
        while self.pos != num.floor(p2):
            d = num.sign(num.floor(p2) - self.pos)
            # step(*d)
            self.pos = self.pos + d
            pygame.draw.line(self.surf,
                             {"down" : (255, 255, 255),
                              "up" : (250,  100, 100)}[self._blade],
                             self.pos * self.scl, self.pos * self.scl)
            if time.time() - self.lastUpdateTime > .1:
                pygame.display.update()
                self.lastUpdateTime = time.time()

    def lineTo(self, p2):
        """proper line to p2"""            
        steps = max(num.absolute(p2 - self.pos))
        print "lineTo", p2, steps
        startPos = self.pos
        for step in range(steps):
            p = num.floor(startPos + (p2 - startPos) * step / (steps - 1))
            self.moveTo(p)

motors = Motors()

def tracePath(path):
    data = parsePathD(path.get('d'))
    for stepType, stepPts in data:
        if stepType == 'M':
            motors.blade("up")
            motors.moveTo(stepPts[0])
        if stepType == 'L':
            motors.blade("down")
            motors.lineTo(stepPts[0])
        if stepType == 'C':
            motors.blade("down")
            # 3 points for the curve
            startCtl, endCtl = stepPts[0], stepPts[1]
            startPos = motors.pos
            endPos = stepPts[2]
            steps = max(num.absolute(endPos - startPos))
            for t in range(steps + 1):
                t /= steps
                p = (    (1 - t)**3 *        startPos+
                     3 * (1 - t)**2 * t *    startCtl +
                     3 * (1 - t) *    t**2 * endCtl +
                                      t**3 * endPos)
                motors.lineTo(p)
#            motors.lineTo(stepPts[2])

def parsePathD(data):
    words = data.split()
    ret = []
    while words:
        word = words.pop(0)
        if word in ['M', 'L']:
            pos = [num.array(map(float, words.pop(0).split(',')))]
            ret.append((word, pos))
        elif word == 'C':
            pts = [num.array(map(float, words.pop(0).split(',')))
                   for loop in range(3)]
            ret.append(('C', pts))
    return ret
    
    
t = ElementTree(file=open(sys.argv[1]))
walk(t.getroot())

#IPShellEmbed()()


print "done"
pygame.display.update()
while 1:
    pygame.event.wait()
